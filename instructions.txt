http://www.cdf.toronto.edu/~csc209h/winter/assignments/a4.html

CSC209 A4 Sockets and Select

Introduction

This is the final assignment of the term, so it’s time to wrap things up by having your file synchronization program work across different machines. In this assignment, you’ll be writing two programs that collaborate to copy files from the client to the server.

As in assignment 3, you may be able to copy snippets of code from previous assignments, so you may want to keep copies of assignment 2 and 3 open. You’ll also find the code from the lectures, the week 10 exercise (client and server), and the week 11 exercise (select) helpful.

NOTE: You must log into MarkUs well before the deadline to “create your group” which either means declaring that you will work alone, or inviting or accepting an invitation from another student.

Requirements

You will write a Makefile and two programs, rcopy_client and rcopy_server. The main function for each program should be written in a file called rcopy_client.c and rcopy_server.c. You are welcome to include additional source and header files. You are welcome to add to and modify the provided files, but should not change the provided structs, size constants or the communication protocol. The communication protocol between the client and the server is fully defined, so we should be able to connect our client to your server and your client to our server.

The two programs should fwork together to copy a file tree from the client machine to the server machine. Here is the process that the two programs will use:

rcopy_client initiates a connection with rcopy_server. The client takes the source file or directory path, and the hostname as an argument. Any path can be passed into the client, but the client will copy the basename (last element on the path) to the server.
The server takes a PREFIX path as argument. This directory path identifies the directory into which files and directories from the client will be copied. The copied files and directories will be copied into the directory PREFIX/sandbox/dest, where sandbox and dest are fixed names. We are doing this to add a little extra security. (See example below.)
rcopy_client immediately identifies itself as a main client by sending the integer CHECKER_CLIENT (see ftree.h). As in the labs, the port to use should be defined using a command line argument set in the Makefile.
rcopy_client, in a single process, walks the file tree (the directory structure). For each file or directory …
rcopy_client sends the server a struct: a path, mode (not just permissions!), hash, and file size. Then, it waits for a response. We have to send the absolute file path since we can’t make assumptions about the current working directory of the server, and we have to send the mode since the server will need to know the type of the file.
rcopy_server responds with the integer MISMATCH (see ftree.h) if its copy of the file differs (so the client should send a copy) and MATCH if the files are the same. At this point, the server may detect that the file types are incompatible, in which case it should send a MATCH_ERROR and emit an error on STDERR. Regardless of whether there is a match or mismatch, the server should update the file’s permissions if it exists.
If the files are the same, the client can continue to the next file.
If the files are different, the server should not update permissions. The client forks a new process. The new client process should initiate a connection with rcopy_server and immediately identify itself as a file sender client by sending the integer SENDER_CLIENT.
The file sender client should send the same struct as before (file path, mode, hash, and file size). Then, without expecting a response, it should transmit the data from the file. After transmitting this data, the file sender client should wait for the message TRANSMIT_OK and then close the socket and exit. If it transmits the file successfully, it should exit with status 0; otherwise, if there is an error (either on the client side or if the message TRANSMIT_ERROR is received), it should print an appropriate message that includes the name of the file that triggered the error and then exit with status 1. No message should be printed if the file transfer is successful.
The server should update the file as data is received from the file sender client and then change the permissions after the file transmission is complete. If those operations succeed, it should send the success message. If it detects some error while writing the data (early termination of the connection or a mismatch in the hash, for example), the server should transmit the error message and then print an appropriate error that includes the name of the file that triggered the error. However, the server should not terminate, as it needs to be available for other clients. No message should be printed if the file transfer is successful.
After forking a child to handle transmitting the file (if necessary), the main client can continue to the next file. It does not need to open a new connection for the next file; the server is expecting the main client to send a sequence of structs. The server should be able to handle multiple simultaneous connections (main clients and file sender clients).
After all files are copied, the main client should close the connection with the server and then wait for children it forked. If all of the file transfers completed successfully and the main client did not encounter an error, it should return a 0. Otherwise, it should return 1.
The server should not terminate after the main client exits. It should continue listening for new clients to connect.
Example

Given the directory structure where adir is a directory containing bdir and file1, and bdir is a directory containing file2.

adir:
    bdir:
        file2
    file1
If the server is run as rcopy_server . where dest is a relative or absolute path on the server, then when we run rcopy_client adir localhost, the contents of dest would look like the following. adir becomes a subdirectory of dest.

sandbox:
    dest: 
        adir:
            bdir:
                file2
                file1
You can assume that if multiple clients attempt to update adir they will be assumed to know that they are updating the same directory structure. You do not need to worry about deleting files or directories on the server or concurrency problems that might arise from having two clients updating the same directory simultaneously.

IMPORTANT: The starter code changes the permissions of sandbox so that it is not writable or executable. This is to prevent a malicious user from using your server to modify files above or outside of sandbox area that we want to use for this application. (I am not promising that this prevents all security breaches, so you should still kill your server whenever you are not testing it.)

This is a bit of a hassle because it means that you have to change the permissions back to executable to remove the files and directory. One thing you could do to reduce the annoyance is write a signal handler that will change the permissions to executable whenever a SIGINT arrives. This is not a required part of the assignment.

Security Concerns

The server does not need to do any checking to make sure that the file sender clients are sending files previously checked by the main client. The clients also do no authentication, so anyone could connect to your server and overwrite your files.

I hope that sounds bad. This is a huge vulnerability. So, (1) change the port in your Makefile to a “secret” number. This is just “security through obscurity”, but it’s a start. (2) Only run your server when you are actively testing and don’t forget to kill it whenever you aren’t using it. (3) We have added a bit of extra code in rcopy_server to provide a bit of extra protection.

Starter Code and File Structure

You will first need to log into MarkUs and navigate to a4 to declare whether you are working alone or in a pair. This causes the directory to be created in your repo, or new repo for your pair to be created. IMPORTANT: MarkUs will not know about your a4 directory if you create it yourself, and we won’t be able to find your assignment work, so you need to log into MarkUs.

You will need to copy the following files into your repository.

ftree.h
hash.h
hash_functions.c
rcopy_client.c
rcopy_server.c
We are providing header files that define the client and server functions to write (ftree.h) and the hash function to provide (hash.h) as well as the main files for the client (rcopy_client.c) and server (rcopy_server.c). All of the code you write should go into ftree.c.

Your first task is to write a Makefile. Your Makefile should have at least four targets: all, the default target that should build both rcopy_client and rcopy_server; rcopy_client; rcopy_server, and clean, which should remove the executables and any intermediate (.o) files. The Makefile should also define at least two variables: PORT, for the port to be used by the client and server, and FLAGS, which should include at least -Wall, -std=gnu99, and -DPORT.

I recommend implementing the client and server in parallel, but in very small steps. For example, start by implementing a server that simply accepts a connection from the client and prints the data that is transmitted to it. Write a client that connects to the server and sends the path it was given. Test. Then, update the client so that it actually pays attention to its arguments and sends the data for a single real file (but don’t recursively trace directories or fork clients to actually send data yet). Test. (For example, print out out the data the client sent in the server). Then, update the sever so it actually tests that specified file and sends a response. Test. Then, update the client and server so that the client can trace through the directory tree and send data about more than one file. Test. Then …

Transmitting Structs

It doesn’t quite work to just send the whole struct on the socket (as we did with a pipe). We need to send each field in succession. As long as the fields are sent in the order expected by the server (first type, then path, then mode, then hash, then file size), the struct can be filled in easily. Since all of the fields in the struct have a fixed size, they are easy to transfer: the client (and server) can simply write (and read) the number of bytes expected for each field. For example, the hash is stored in an array of BLOCKSIZE chars, so BLOCKSIZE bytes should be transmitted.

There are three issues to be careful of. First, make sure to send all of the bytes expected. For example, even if the path is only 16 bytes long, the full MAXPATH bytes should be transmitted. Second, be sure to translate any numeric types to and from network order (using htonl and ntohl, for example), in case the systems have different endianness. Third, remember that after a select call, it is only safe to call read once. So you can’t just write four read calls in a row to read the fields of the struct, you will need to keep track of the state of what you have read so far and allow select to be called in between each read call.

For example, the initial state is AWAITING_TYPE so the first thing the server expects to read from a client is the request type. After it has read the type, the state of this client should change to AWAITING_PATH because the next thing the server expects to read from the client is the path.

Links and Hidden Files

As in previous assignments, your programs do not need to handle links or files that start with “.”. If the client encounters a symbolic link or a file starting with “.”, it should skip it.

As you saw in the previous assignment, identifying that two files are hard links of the same underlying data is difficult, so you are not expected to do so. Two files that are hard links of the same underlying data on the client will result in two separate files on the server.

Submission and Marking

Your submission should be committed (and pushed) to your git repository by the due date. As before, we are using automated grading tools to provide functional feedback, so it’s important that your submission be in the correct location in your repository (under a4/), have the correct filenames (all of your code – client and server – should be in ftree.c except for the hash function, which should be in hash_functions.c), not include the safety mechanism described earlier, be fully submitted (remember to add the Makefile and any other new files, commit, and push), compile cleanly, and produce output when requested (and only when requested).

Your program must compile on a CS lab machine, so please test it there before submission. We will be using gccto compile program with the flags -Wall and -std=gnu99. Your program should not produce any error or warning messages when compiled. As in assignments 1-3, programs that do not compile will receive a 0. Programs that produce warning messages will be penalized.